// attr [max_alpha3] storage_scope = "global"
allocate max_alpha3[float32 * 1]
produce max_alpha3 {
  // attr [0] extern_scope = 0
  max_alpha3[0] = -1000000000.000000f
}
// attr [max_alpha1] storage_scope = "global"
allocate max_alpha1[float32 * 1]
produce max_alpha1 {
  // attr [0] extern_scope = 0
  max_alpha1[0] = -1000000000.000000f
}
// attr [max_alpha2] storage_scope = "global"
allocate max_alpha2[float32 * 1]
produce max_alpha2 {
  // attr [0] extern_scope = 0
  max_alpha2[0] = -1000000000.000000f
}
// attr [Hamiltonian] storage_scope = "global"
allocate Hamiltonian[float32 * 1]
produce Hamiltonian {
  // attr [0] extern_scope = 0
  for (k.outer, 0, 25) {
    for (j.outer, 0, 25) {
      unrolled "factor"=5 (i.outer, 0, 25) {
        pipelined "initiation_interval"=1 (k.inner, 0, 4) {
          for (j.inner, 0, 4) {
            for (i.inner, 0, 4) {
              // attr [dV_dx_L] storage_scope = "global"
              allocate dV_dx_L[float32 * 1]
              produce dV_dx_L {
                // attr [0] extern_scope = 0
                dV_dx_L[0] = 0.000000f
              }
              // attr [dV_dx_R] storage_scope = "global"
              allocate dV_dx_R[float32 * 1]
              produce dV_dx_R {
                // attr [0] extern_scope = 0
                dV_dx_R[0] = 0.000000f
              }
              // attr [dV_dx] storage_scope = "global"
              allocate dV_dx[float32 * 1]
              produce dV_dx {
                // attr [0] extern_scope = 0
                dV_dx[0] = 0.000000f
              }
              // attr [dV_dy_L] storage_scope = "global"
              allocate dV_dy_L[float32 * 1]
              produce dV_dy_L {
                // attr [0] extern_scope = 0
                dV_dy_L[0] = 0.000000f
              }
              // attr [dV_dy_R] storage_scope = "global"
              allocate dV_dy_R[float32 * 1]
              produce dV_dy_R {
                // attr [0] extern_scope = 0
                dV_dy_R[0] = 0.000000f
              }
              // attr [dV_dy] storage_scope = "global"
              allocate dV_dy[float32 * 1]
              produce dV_dy {
                // attr [0] extern_scope = 0
                dV_dy[0] = 0.000000f
              }
              // attr [dV_dT_L] storage_scope = "global"
              allocate dV_dT_L[float32 * 1]
              produce dV_dT_L {
                // attr [0] extern_scope = 0
                dV_dT_L[0] = 0.000000f
              }
              // attr [dV_dT_R] storage_scope = "global"
              allocate dV_dT_R[float32 * 1]
              produce dV_dT_R {
                // attr [0] extern_scope = 0
                dV_dT_R[0] = 0.000000f
              }
              // attr [dV_dT] storage_scope = "global"
              allocate dV_dT[float32 * 1]
              produce dV_dT {
                // attr [0] extern_scope = 0
                dV_dT[0] = 0.000000f
              }
              // attr [dx_dt] storage_scope = "global"
              allocate dx_dt[float32 * 1]
              produce dx_dt {
                // attr [0] extern_scope = 0
                dx_dt[0] = 0.000000f
              }
              // attr [dy_dt] storage_scope = "global"
              allocate dy_dt[float32 * 1]
              produce dy_dt {
                // attr [0] extern_scope = 0
                dy_dt[0] = 0.000000f
              }
              // attr [dtheta_dt] storage_scope = "global"
              allocate dtheta_dt[float32 * 1]
              produce dtheta_dt {
                // attr [0] extern_scope = 0
                dtheta_dt[0] = 0.000000f
              }
              // attr [left_deriv] storage_scope = "global"
              allocate left_deriv[float32 * 1]
              produce left_deriv {
                // attr [0] extern_scope = 0
                left_deriv[0] = 0.000000f
              }
              // attr [right_deriv] storage_scope = "global"
              allocate right_deriv[float32 * 1]
              produce right_deriv {
                // attr [0] extern_scope = 0
                right_deriv[0] = 0.000000f
              }
              if (((i.inner + (i.outer*4)) == 0)) {
                // attr [left_boundary] storage_scope = "global"
                allocate left_boundary[float32 * 1]
                produce left_boundary {
                  // attr [0] extern_scope = 0
                  left_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)] - V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)] - V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))])
                } else {
                  abs_value[0] = (V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                left_boundary[0] = (V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] - left_boundary[0])*2.941176f)
                right_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)] - V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))])*2.941176f)
              } else if (((i.inner + (i.outer*4)) == 99)) {
                // attr [right_boundary] storage_scope = "global"
                allocate right_boundary[float32 * 1]
                produce right_boundary {
                  // attr [0] extern_scope = 0
                  right_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)])
                } else {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                right_boundary[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)])*2.941176f)
                right_deriv[0] = ((right_boundary[0] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)])*2.941176f)
              } else if (((i.inner + (i.outer*4)) != 99)) {
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] - V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + -10000)])*2.941176f)
                right_deriv[0] = ((V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + 10000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])*2.941176f)
              }
              dV_dx_L[0] = left_deriv[0]
              dV_dx_R[0] = right_deriv[0]
              // attr [left_deriv] storage_scope = "global"
              allocate left_deriv[float32 * 1]
              produce left_deriv {
                // attr [0] extern_scope = 0
                left_deriv[0] = 0.000000f
              }
              // attr [right_deriv] storage_scope = "global"
              allocate right_deriv[float32 * 1]
              produce right_deriv {
                // attr [0] extern_scope = 0
                right_deriv[0] = 0.000000f
              }
              if (((j.inner + (j.outer*4)) == 0)) {
                // attr [left_boundary] storage_scope = "global"
                allocate left_boundary[float32 * 1]
                produce left_boundary {
                  // attr [0] extern_scope = 0
                  left_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))])
                } else {
                  abs_value[0] = (V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                left_boundary[0] = (V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] - left_boundary[0])*4.545455f)
                right_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))])*4.545455f)
              } else if (((j.inner + (j.outer*4)) == 99)) {
                // attr [right_boundary] storage_scope = "global"
                allocate right_boundary[float32 * 1]
                produce right_boundary {
                  // attr [0] extern_scope = 0
                  right_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)])
                } else {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                right_boundary[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)])*4.545455f)
                right_deriv[0] = ((right_boundary[0] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)])*4.545455f)
              } else if (((j.inner + (j.outer*4)) != 99)) {
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] - V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + -100)])*4.545455f)
                right_deriv[0] = ((V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])*4.545455f)
              }
              dV_dy_L[0] = left_deriv[0]
              dV_dy_R[0] = right_deriv[0]
              // attr [left_deriv] storage_scope = "global"
              allocate left_deriv[float32 * 1]
              produce left_deriv {
                // attr [0] extern_scope = 0
                left_deriv[0] = 0.000000f
              }
              // attr [right_deriv] storage_scope = "global"
              allocate right_deriv[float32 * 1]
              produce right_deriv {
                // attr [0] extern_scope = 0
                right_deriv[0] = 0.000000f
              }
              if (((k.inner + (k.outer*4)) == 0)) {
                // attr [left_boundary] storage_scope = "global"
                allocate left_boundary[float32 * 1]
                produce left_boundary {
                  // attr [0] extern_scope = 0
                  left_boundary[0] = 0.000000f
                }
                left_boundary[0] = V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 50)]
                left_deriv[0] = ((V_init[(((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100)] - left_boundary[0])*4.761905f)
                right_deriv[0] = ((V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 1)] - V_init[(((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100)])*4.761905f)
              } else if (((k.inner + (k.outer*4)) == 99)) {
                // attr [right_boundary] storage_scope = "global"
                allocate right_boundary[float32 * 1]
                produce right_boundary {
                  // attr [0] extern_scope = 0
                  right_boundary[0] = 0.000000f
                }
                right_boundary[0] = V_init[(((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100)]
                left_deriv[0] = ((V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 99)] - V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 98)])*4.761905f)
                right_deriv[0] = ((right_boundary[0] - V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 99)])*4.761905f)
              } else if (((k.inner + (k.outer*4)) != 99)) {
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] - V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + -1)])*4.761905f)
                right_deriv[0] = ((V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + 1)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])*4.761905f)
              }
              dV_dT_L[0] = left_deriv[0]
              dV_dT_R[0] = right_deriv[0]
              dV_dx[0] = ((dV_dx_L[0] + dV_dx_R[0])*0.500000f)
              dV_dy[0] = ((dV_dy_L[0] + dV_dy_R[0])*0.500000f)
              dV_dT[0] = ((dV_dT_L[0] + dV_dT_R[0])*0.500000f)
              // attr [uOpt] storage_scope = "global"
              allocate uOpt[float32 * 1]
              produce uOpt {
                // attr [0] extern_scope = 0
                uOpt[0] = 0.000000f
              }
              // attr [vel] storage_scope = "global"
              allocate vel[float32 * 1]
              produce vel {
                // attr [0] extern_scope = 0
                vel[0] = 1.000000f
              }
              if ((0.000000f < dV_dT[0])) {
                uOpt[0] = (uOpt[0]*-1.000000f)
              }
              dx_dt[0] = float32((float64(vel[0])*cos(float64(thetas[(k.inner + (k.outer*4))]))))
              dy_dt[0] = float32((float64(vel[0])*sin(float64(thetas[(k.inner + (k.outer*4))]))))
              dtheta_dt[0] = uOpt[0]
              V_f[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] = ((((dx_dt[0]*dV_dx[0]) + (dy_dt[0]*dV_dy[0])) + (dtheta_dt[0]*dV_dT[0]))*-1.000000f)
              // attr [abs_value] storage_scope = "global"
              allocate abs_value[float32 * 1]
              produce abs_value {
                // attr [0] extern_scope = 0
                abs_value[0] = 0.000000f
              }
              if ((0.000000f < dx_dt[0])) {
                abs_value[0] = dx_dt[0]
              } else {
                abs_value[0] = (dx_dt[0]*-1.000000f)
              }
              dx_dt[0] = abs_value[0]
              // attr [abs_value] storage_scope = "global"
              allocate abs_value[float32 * 1]
              produce abs_value {
                // attr [0] extern_scope = 0
                abs_value[0] = 0.000000f
              }
              if ((0.000000f < dy_dt[0])) {
                abs_value[0] = dy_dt[0]
              } else {
                abs_value[0] = (dy_dt[0]*-1.000000f)
              }
              dy_dt[0] = abs_value[0]
              // attr [abs_value] storage_scope = "global"
              allocate abs_value[float32 * 1]
              produce abs_value {
                // attr [0] extern_scope = 0
                abs_value[0] = 0.000000f
              }
              if ((0.000000f < dtheta_dt[0])) {
                abs_value[0] = dtheta_dt[0]
              } else {
                abs_value[0] = (dtheta_dt[0]*-1.000000f)
              }
              dtheta_dt[0] = abs_value[0]
              // attr [diss] storage_scope = "global"
              allocate diss[float32 * 1]
              produce diss {
                // attr [0] extern_scope = 0
                diss[0] = 0.000000f
              }
              diss[0] = (((((dV_dx_R[0] - dV_dx_L[0])*dx_dt[0]) + ((dV_dy_R[0] - dV_dy_L[0])*dy_dt[0])) + ((dV_dT_R[0] - dV_dT_L[0])*dtheta_dt[0]))*0.500000f)
              V_f[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] = (diss[0] - V_f[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])
              if ((max_alpha1[0] < dx_dt[0])) {
                max_alpha1[0] = dx_dt[0]
              }
              if ((max_alpha2[0] < dy_dt[0])) {
                max_alpha2[0] = dy_dt[0]
              }
              if ((max_alpha3[0] < dtheta_dt[0])) {
                max_alpha3[0] = dtheta_dt[0]
              }
            }
          }
        }
      }
    }
  }
}
// attr [update0] storage_scope = "global"
allocate update0[float32 * 1]
produce update0 {
  // attr [0] extern_scope = 0
  // attr [stepBoundInv] storage_scope = "global"
  allocate stepBoundInv[float32 * 1]
  produce stepBoundInv {
    // attr [0] extern_scope = 0
    stepBoundInv[0] = 0.000000f
  }
  // attr [stepBound] storage_scope = "global"
  allocate stepBound[float32 * 1]
  produce stepBound {
    // attr [0] extern_scope = 0
    stepBound[0] = 0.000000f
  }
  stepBoundInv[0] = (((max_alpha1[0]*2.941176f) + (max_alpha2[0]*4.545455f)) + (max_alpha3[0]*4.761905f))
  stepBound[0] = (0.800000f/stepBoundInv[0])
  if ((0.050000f < stepBound[0])) {
    stepBound[0] = 0.050000f
  }
  t[0] = (t[0] + stepBound[0])
}
// attr [update1] storage_scope = "global"
allocate update1[float32 * 1]
produce update1 {
  // attr [0] extern_scope = 0
  for (i, 0, 100) {
    for (j, 0, 100) {
      for (k, 0, 100) {
        V_f[((k + (j*100)) + (i*10000))] = (V_init[((k + (j*100)) + (i*10000))] + (V_f[((k + (j*100)) + (i*10000))]*t[0]))
      }
    }
  }
}

// attr [max_alpha1] storage_scope = "global"
allocate max_alpha1[float32 * 1]
produce max_alpha1 {
  // attr [0] extern_scope = 0
  max_alpha1[0] = -1000000000.000000f
}
// attr [max_alpha2] storage_scope = "global"
allocate max_alpha2[float32 * 1]
produce max_alpha2 {
  // attr [0] extern_scope = 0
  max_alpha2[0] = -1000000000.000000f
}
// attr [max_alpha3] storage_scope = "global"
allocate max_alpha3[float32 * 1]
produce max_alpha3 {
  // attr [0] extern_scope = 0
  max_alpha3[0] = -1000000000.000000f
}
// attr [Hamiltonian] storage_scope = "global"
allocate Hamiltonian[float32 * 1]
produce Hamiltonian {
  // attr [0] extern_scope = 0
  for (k.outer, 0, 25) {
    for (j.outer, 0, 25) {
      parallel "factor"=5 (i.outer, 0, 25) {
        pipelined "initiation_interval"=1 (k.inner, 0, 4) {
          for (j.inner, 0, 4) {
            for (i.inner, 0, 4) {
              // attr [dV_dx_L] storage_scope = "global"
              allocate dV_dx_L[float32 * 1]
              produce dV_dx_L {
                // attr [0] extern_scope = 0
                dV_dx_L[0] = 0.000000f
              }
              // attr [dV_dx_R] storage_scope = "global"
              allocate dV_dx_R[float32 * 1]
              produce dV_dx_R {
                // attr [0] extern_scope = 0
                dV_dx_R[0] = 0.000000f
              }
              // attr [dV_dx] storage_scope = "global"
              allocate dV_dx[float32 * 1]
              produce dV_dx {
                // attr [0] extern_scope = 0
                dV_dx[0] = 0.000000f
              }
              // attr [dV_dy_L] storage_scope = "global"
              allocate dV_dy_L[float32 * 1]
              produce dV_dy_L {
                // attr [0] extern_scope = 0
                dV_dy_L[0] = 0.000000f
              }
              // attr [dV_dy_R] storage_scope = "global"
              allocate dV_dy_R[float32 * 1]
              produce dV_dy_R {
                // attr [0] extern_scope = 0
                dV_dy_R[0] = 0.000000f
              }
              // attr [dV_dy] storage_scope = "global"
              allocate dV_dy[float32 * 1]
              produce dV_dy {
                // attr [0] extern_scope = 0
                dV_dy[0] = 0.000000f
              }
              // attr [dV_dT_L] storage_scope = "global"
              allocate dV_dT_L[float32 * 1]
              produce dV_dT_L {
                // attr [0] extern_scope = 0
                dV_dT_L[0] = 0.000000f
              }
              // attr [dV_dT_R] storage_scope = "global"
              allocate dV_dT_R[float32 * 1]
              produce dV_dT_R {
                // attr [0] extern_scope = 0
                dV_dT_R[0] = 0.000000f
              }
              // attr [dV_dT] storage_scope = "global"
              allocate dV_dT[float32 * 1]
              produce dV_dT {
                // attr [0] extern_scope = 0
                dV_dT[0] = 0.000000f
              }
              // attr [dx_dt] storage_scope = "global"
              allocate dx_dt[float32 * 1]
              produce dx_dt {
                // attr [0] extern_scope = 0
                dx_dt[0] = 0.000000f
              }
              // attr [dy_dt] storage_scope = "global"
              allocate dy_dt[float32 * 1]
              produce dy_dt {
                // attr [0] extern_scope = 0
                dy_dt[0] = 0.000000f
              }
              // attr [dtheta_dt] storage_scope = "global"
              allocate dtheta_dt[float32 * 1]
              produce dtheta_dt {
                // attr [0] extern_scope = 0
                dtheta_dt[0] = 0.000000f
              }
              // attr [left_deriv] storage_scope = "global"
              allocate left_deriv[float32 * 1]
              produce left_deriv {
                // attr [0] extern_scope = 0
                left_deriv[0] = 0.000000f
              }
              // attr [right_deriv] storage_scope = "global"
              allocate right_deriv[float32 * 1]
              produce right_deriv {
                // attr [0] extern_scope = 0
                right_deriv[0] = 0.000000f
              }
              if (((i.inner + (i.outer*4)) == 0)) {
                // attr [left_boundary] storage_scope = "global"
                allocate left_boundary[float32 * 1]
                produce left_boundary {
                  // attr [0] extern_scope = 0
                  left_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)] - V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)] - V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))])
                } else {
                  abs_value[0] = (V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                left_boundary[0] = (V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] - left_boundary[0])*2.941176f)
                right_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)] - V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))])*2.941176f)
              } else if (((i.inner + (i.outer*4)) == 99)) {
                // attr [right_boundary] storage_scope = "global"
                allocate right_boundary[float32 * 1]
                produce right_boundary {
                  // attr [0] extern_scope = 0
                  right_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)])
                } else {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                right_boundary[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)])*2.941176f)
                right_deriv[0] = ((right_boundary[0] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)])*2.941176f)
              } else if (((i.inner + (i.outer*4)) != 99)) {
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] - V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + -10000)])*2.941176f)
                right_deriv[0] = ((V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + 10000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])*2.941176f)
              }
              dV_dx_L[0] = left_deriv[0]
              dV_dx_R[0] = right_deriv[0]
              // attr [left_deriv] storage_scope = "global"
              allocate left_deriv[float32 * 1]
              produce left_deriv {
                // attr [0] extern_scope = 0
                left_deriv[0] = 0.000000f
              }
              // attr [right_deriv] storage_scope = "global"
              allocate right_deriv[float32 * 1]
              produce right_deriv {
                // attr [0] extern_scope = 0
                right_deriv[0] = 0.000000f
              }
              if (((j.inner + (j.outer*4)) == 0)) {
                // attr [left_boundary] storage_scope = "global"
                allocate left_boundary[float32 * 1]
                produce left_boundary {
                  // attr [0] extern_scope = 0
                  left_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))])
                } else {
                  abs_value[0] = (V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                left_boundary[0] = (V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] - left_boundary[0])*4.545455f)
                right_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))])*4.545455f)
              } else if (((j.inner + (j.outer*4)) == 99)) {
                // attr [right_boundary] storage_scope = "global"
                allocate right_boundary[float32 * 1]
                produce right_boundary {
                  // attr [0] extern_scope = 0
                  right_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)])
                } else {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                right_boundary[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)])*4.545455f)
                right_deriv[0] = ((right_boundary[0] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)])*4.545455f)
              } else if (((j.inner + (j.outer*4)) != 99)) {
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] - V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + -100)])*4.545455f)
                right_deriv[0] = ((V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])*4.545455f)
              }
              dV_dy_L[0] = left_deriv[0]
              dV_dy_R[0] = right_deriv[0]
              // attr [left_deriv] storage_scope = "global"
              allocate left_deriv[float32 * 1]
              produce left_deriv {
                // attr [0] extern_scope = 0
                left_deriv[0] = 0.000000f
              }
              // attr [right_deriv] storage_scope = "global"
              allocate right_deriv[float32 * 1]
              produce right_deriv {
                // attr [0] extern_scope = 0
                right_deriv[0] = 0.000000f
              }
              if (((k.inner + (k.outer*4)) == 0)) {
                // attr [left_boundary] storage_scope = "global"
                allocate left_boundary[float32 * 1]
                produce left_boundary {
                  // attr [0] extern_scope = 0
                  left_boundary[0] = 0.000000f
                }
                left_boundary[0] = V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 50)]
                left_deriv[0] = ((V_init[(((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100)] - left_boundary[0])*4.761905f)
                right_deriv[0] = ((V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 1)] - V_init[(((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100)])*4.761905f)
              } else if (((k.inner + (k.outer*4)) == 99)) {
                // attr [right_boundary] storage_scope = "global"
                allocate right_boundary[float32 * 1]
                produce right_boundary {
                  // attr [0] extern_scope = 0
                  right_boundary[0] = 0.000000f
                }
                right_boundary[0] = V_init[(((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100)]
                left_deriv[0] = ((V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 99)] - V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 98)])*4.761905f)
                right_deriv[0] = ((right_boundary[0] - V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 99)])*4.761905f)
              } else if (((k.inner + (k.outer*4)) != 99)) {
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] - V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + -1)])*4.761905f)
                right_deriv[0] = ((V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + 1)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])*4.761905f)
              }
              dV_dT_L[0] = left_deriv[0]
              dV_dT_R[0] = right_deriv[0]
              dV_dx[0] = ((dV_dx_L[0] + dV_dx_R[0])*0.500000f)
              dV_dy[0] = ((dV_dy_L[0] + dV_dy_R[0])*0.500000f)
              dV_dT[0] = ((dV_dT_L[0] + dV_dT_R[0])*0.500000f)
              // attr [uOpt] storage_scope = "global"
              allocate uOpt[float32 * 1]
              produce uOpt {
                // attr [0] extern_scope = 0
                uOpt[0] = 0.000000f
              }
              // attr [vel] storage_scope = "global"
              allocate vel[float32 * 1]
              produce vel {
                // attr [0] extern_scope = 0
                vel[0] = 1.000000f
              }
              if ((0.000000f < dV_dT[0])) {
                uOpt[0] = (uOpt[0]*-1.000000f)
              }
              dx_dt[0] = float32((float64(vel[0])*cos(float64(thetas[(k.inner + (k.outer*4))]))))
              dy_dt[0] = float32((float64(vel[0])*sin(float64(thetas[(k.inner + (k.outer*4))]))))
              dtheta_dt[0] = uOpt[0]
              V_f[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] = ((((dx_dt[0]*dV_dx[0]) + (dy_dt[0]*dV_dy[0])) + (dtheta_dt[0]*dV_dT[0]))*-1.000000f)
              // attr [abs_value] storage_scope = "global"
              allocate abs_value[float32 * 1]
              produce abs_value {
                // attr [0] extern_scope = 0
                abs_value[0] = 0.000000f
              }
              if ((0.000000f < dx_dt[0])) {
                abs_value[0] = dx_dt[0]
              } else {
                abs_value[0] = (dx_dt[0]*-1.000000f)
              }
              dx_dt[0] = abs_value[0]
              // attr [abs_value] storage_scope = "global"
              allocate abs_value[float32 * 1]
              produce abs_value {
                // attr [0] extern_scope = 0
                abs_value[0] = 0.000000f
              }
              if ((0.000000f < dy_dt[0])) {
                abs_value[0] = dy_dt[0]
              } else {
                abs_value[0] = (dy_dt[0]*-1.000000f)
              }
              dy_dt[0] = abs_value[0]
              // attr [abs_value] storage_scope = "global"
              allocate abs_value[float32 * 1]
              produce abs_value {
                // attr [0] extern_scope = 0
                abs_value[0] = 0.000000f
              }
              if ((0.000000f < dtheta_dt[0])) {
                abs_value[0] = dtheta_dt[0]
              } else {
                abs_value[0] = (dtheta_dt[0]*-1.000000f)
              }
              dtheta_dt[0] = abs_value[0]
              // attr [diss] storage_scope = "global"
              allocate diss[float32 * 1]
              produce diss {
                // attr [0] extern_scope = 0
                diss[0] = 0.000000f
              }
              diss[0] = (((((dV_dx_R[0] - dV_dx_L[0])*dx_dt[0]) + ((dV_dy_R[0] - dV_dy_L[0])*dy_dt[0])) + ((dV_dT_R[0] - dV_dT_L[0])*dtheta_dt[0]))*0.500000f)
              V_f[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] = (diss[0] - V_f[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])
              if ((max_alpha1[0] < dx_dt[0])) {
                max_alpha1[0] = dx_dt[0]
              }
              if ((max_alpha2[0] < dy_dt[0])) {
                max_alpha2[0] = dy_dt[0]
              }
              if ((max_alpha3[0] < dtheta_dt[0])) {
                max_alpha3[0] = dtheta_dt[0]
              }
            }
          }
        }
      }
    }
  }
}
// attr [update0] storage_scope = "global"
allocate update0[float32 * 1]
produce update0 {
  // attr [0] extern_scope = 0
  // attr [stepBoundInv] storage_scope = "global"
  allocate stepBoundInv[float32 * 1]
  produce stepBoundInv {
    // attr [0] extern_scope = 0
    stepBoundInv[0] = 0.000000f
  }
  // attr [stepBound] storage_scope = "global"
  allocate stepBound[float32 * 1]
  produce stepBound {
    // attr [0] extern_scope = 0
    stepBound[0] = 0.000000f
  }
  stepBoundInv[0] = (((max_alpha1[0]*2.941176f) + (max_alpha2[0]*4.545455f)) + (max_alpha3[0]*4.761905f))
  stepBound[0] = (0.800000f/stepBoundInv[0])
  if ((0.050000f < stepBound[0])) {
    stepBound[0] = 0.050000f
  }
  t[0] = (t[0] + stepBound[0])
}
// attr [update1] storage_scope = "global"
allocate update1[float32 * 1]
produce update1 {
  // attr [0] extern_scope = 0
  for (i, 0, 100) {
    for (j, 0, 100) {
      for (k, 0, 100) {
        V_f[((k + (j*100)) + (i*10000))] = (V_init[((k + (j*100)) + (i*10000))] + (V_f[((k + (j*100)) + (i*10000))]*t[0]))
      }
    }
  }
}

Kernel time (s): 0.03480
Kernel time (s): 0.01197
Kernel time (s): 0.01250
Kernel time (s): 0.01253
Kernel time (s): 0.01285
Kernel time (s): 0.01288
Kernel time (s): 0.01279
Kernel time (s): 0.01291
Kernel time (s): 0.01281
Kernel time (s): 0.01318
Kernel time (s): 0.01286
Kernel time (s): 0.01298
Kernel time (s): 0.01291
Kernel time (s): 0.01318
Kernel time (s): 0.01288
Kernel time (s): 0.01286
Kernel time (s): 0.01287
Kernel time (s): 0.01295
Kernel time (s): 0.01282
Kernel time (s): 0.01285
Average kernel time (s): 0.01392
Finished solving

// attr [max_alpha2] storage_scope = "global"
allocate max_alpha2[float32 * 1]
produce max_alpha2 {
  // attr [0] extern_scope = 0
  max_alpha2[0] = -1000000000.000000f
}
// attr [max_alpha1] storage_scope = "global"
allocate max_alpha1[float32 * 1]
produce max_alpha1 {
  // attr [0] extern_scope = 0
  max_alpha1[0] = -1000000000.000000f
}
// attr [max_alpha3] storage_scope = "global"
allocate max_alpha3[float32 * 1]
produce max_alpha3 {
  // attr [0] extern_scope = 0
  max_alpha3[0] = -1000000000.000000f
}
// attr [Hamiltonian] storage_scope = "global"
allocate Hamiltonian[float32 * 1]
produce Hamiltonian {
  // attr [0] extern_scope = 0
  for (k.outer, 0, 25) {
    for (j.outer, 0, 25) {
      parallel (i.outer, 0, 25) {
        for (k.inner, 0, 4) {
          for (j.inner, 0, 4) {
            for (i.inner, 0, 4) {
              // attr [dV_dx_L] storage_scope = "global"
              allocate dV_dx_L[float32 * 1]
              produce dV_dx_L {
                // attr [0] extern_scope = 0
                dV_dx_L[0] = 0.000000f
              }
              // attr [dV_dx_R] storage_scope = "global"
              allocate dV_dx_R[float32 * 1]
              produce dV_dx_R {
                // attr [0] extern_scope = 0
                dV_dx_R[0] = 0.000000f
              }
              // attr [dV_dx] storage_scope = "global"
              allocate dV_dx[float32 * 1]
              produce dV_dx {
                // attr [0] extern_scope = 0
                dV_dx[0] = 0.000000f
              }
              // attr [dV_dy_L] storage_scope = "global"
              allocate dV_dy_L[float32 * 1]
              produce dV_dy_L {
                // attr [0] extern_scope = 0
                dV_dy_L[0] = 0.000000f
              }
              // attr [dV_dy_R] storage_scope = "global"
              allocate dV_dy_R[float32 * 1]
              produce dV_dy_R {
                // attr [0] extern_scope = 0
                dV_dy_R[0] = 0.000000f
              }
              // attr [dV_dy] storage_scope = "global"
              allocate dV_dy[float32 * 1]
              produce dV_dy {
                // attr [0] extern_scope = 0
                dV_dy[0] = 0.000000f
              }
              // attr [dV_dT_L] storage_scope = "global"
              allocate dV_dT_L[float32 * 1]
              produce dV_dT_L {
                // attr [0] extern_scope = 0
                dV_dT_L[0] = 0.000000f
              }
              // attr [dV_dT_R] storage_scope = "global"
              allocate dV_dT_R[float32 * 1]
              produce dV_dT_R {
                // attr [0] extern_scope = 0
                dV_dT_R[0] = 0.000000f
              }
              // attr [dV_dT] storage_scope = "global"
              allocate dV_dT[float32 * 1]
              produce dV_dT {
                // attr [0] extern_scope = 0
                dV_dT[0] = 0.000000f
              }
              // attr [dx_dt] storage_scope = "global"
              allocate dx_dt[float32 * 1]
              produce dx_dt {
                // attr [0] extern_scope = 0
                dx_dt[0] = 0.000000f
              }
              // attr [dy_dt] storage_scope = "global"
              allocate dy_dt[float32 * 1]
              produce dy_dt {
                // attr [0] extern_scope = 0
                dy_dt[0] = 0.000000f
              }
              // attr [dtheta_dt] storage_scope = "global"
              allocate dtheta_dt[float32 * 1]
              produce dtheta_dt {
                // attr [0] extern_scope = 0
                dtheta_dt[0] = 0.000000f
              }
              // attr [left_deriv] storage_scope = "global"
              allocate left_deriv[float32 * 1]
              produce left_deriv {
                // attr [0] extern_scope = 0
                left_deriv[0] = 0.000000f
              }
              // attr [right_deriv] storage_scope = "global"
              allocate right_deriv[float32 * 1]
              produce right_deriv {
                // attr [0] extern_scope = 0
                right_deriv[0] = 0.000000f
              }
              if (((i.inner + (i.outer*4)) == 0)) {
                // attr [left_boundary] storage_scope = "global"
                allocate left_boundary[float32 * 1]
                produce left_boundary {
                  // attr [0] extern_scope = 0
                  left_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)] - V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)] - V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))])
                } else {
                  abs_value[0] = (V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                left_boundary[0] = (V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] - left_boundary[0])*2.941176f)
                right_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)] - V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))])*2.941176f)
              } else if (((i.inner + (i.outer*4)) == 99)) {
                // attr [right_boundary] storage_scope = "global"
                allocate right_boundary[float32 * 1]
                produce right_boundary {
                  // attr [0] extern_scope = 0
                  right_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)])
                } else {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                right_boundary[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)])*2.941176f)
                right_deriv[0] = ((right_boundary[0] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)])*2.941176f)
              } else if (((i.inner + (i.outer*4)) != 99)) {
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] - V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + -10000)])*2.941176f)
                right_deriv[0] = ((V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + 10000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])*2.941176f)
              }
              dV_dx_L[0] = left_deriv[0]
              dV_dx_R[0] = right_deriv[0]
              // attr [left_deriv] storage_scope = "global"
              allocate left_deriv[float32 * 1]
              produce left_deriv {
                // attr [0] extern_scope = 0
                left_deriv[0] = 0.000000f
              }
              // attr [right_deriv] storage_scope = "global"
              allocate right_deriv[float32 * 1]
              produce right_deriv {
                // attr [0] extern_scope = 0
                right_deriv[0] = 0.000000f
              }
              if (((j.inner + (j.outer*4)) == 0)) {
                // attr [left_boundary] storage_scope = "global"
                allocate left_boundary[float32 * 1]
                produce left_boundary {
                  // attr [0] extern_scope = 0
                  left_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))])
                } else {
                  abs_value[0] = (V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                left_boundary[0] = (V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] - left_boundary[0])*4.545455f)
                right_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))])*4.545455f)
              } else if (((j.inner + (j.outer*4)) == 99)) {
                // attr [right_boundary] storage_scope = "global"
                allocate right_boundary[float32 * 1]
                produce right_boundary {
                  // attr [0] extern_scope = 0
                  right_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)])
                } else {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                right_boundary[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)])*4.545455f)
                right_deriv[0] = ((right_boundary[0] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)])*4.545455f)
              } else if (((j.inner + (j.outer*4)) != 99)) {
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] - V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + -100)])*4.545455f)
                right_deriv[0] = ((V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])*4.545455f)
              }
              dV_dy_L[0] = left_deriv[0]
              dV_dy_R[0] = right_deriv[0]
              // attr [left_deriv] storage_scope = "global"
              allocate left_deriv[float32 * 1]
              produce left_deriv {
                // attr [0] extern_scope = 0
                left_deriv[0] = 0.000000f
              }
              // attr [right_deriv] storage_scope = "global"
              allocate right_deriv[float32 * 1]
              produce right_deriv {
                // attr [0] extern_scope = 0
                right_deriv[0] = 0.000000f
              }
              if (((k.inner + (k.outer*4)) == 0)) {
                // attr [left_boundary] storage_scope = "global"
                allocate left_boundary[float32 * 1]
                produce left_boundary {
                  // attr [0] extern_scope = 0
                  left_boundary[0] = 0.000000f
                }
                left_boundary[0] = V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 50)]
                left_deriv[0] = ((V_init[(((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100)] - left_boundary[0])*4.761905f)
                right_deriv[0] = ((V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 1)] - V_init[(((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100)])*4.761905f)
              } else if (((k.inner + (k.outer*4)) == 99)) {
                // attr [right_boundary] storage_scope = "global"
                allocate right_boundary[float32 * 1]
                produce right_boundary {
                  // attr [0] extern_scope = 0
                  right_boundary[0] = 0.000000f
                }
                right_boundary[0] = V_init[(((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100)]
                left_deriv[0] = ((V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 99)] - V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 98)])*4.761905f)
                right_deriv[0] = ((right_boundary[0] - V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 99)])*4.761905f)
              } else if (((k.inner + (k.outer*4)) != 99)) {
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] - V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + -1)])*4.761905f)
                right_deriv[0] = ((V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + 1)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])*4.761905f)
              }
              dV_dT_L[0] = left_deriv[0]
              dV_dT_R[0] = right_deriv[0]
              dV_dx[0] = ((dV_dx_L[0] + dV_dx_R[0])*0.500000f)
              dV_dy[0] = ((dV_dy_L[0] + dV_dy_R[0])*0.500000f)
              dV_dT[0] = ((dV_dT_L[0] + dV_dT_R[0])*0.500000f)
              // attr [uOpt] storage_scope = "global"
              allocate uOpt[float32 * 1]
              produce uOpt {
                // attr [0] extern_scope = 0
                uOpt[0] = 0.000000f
              }
              // attr [vel] storage_scope = "global"
              allocate vel[float32 * 1]
              produce vel {
                // attr [0] extern_scope = 0
                vel[0] = 1.000000f
              }
              if ((0.000000f < dV_dT[0])) {
                uOpt[0] = (uOpt[0]*-1.000000f)
              }
              dx_dt[0] = float32((float64(vel[0])*cos(float64(thetas[(k.inner + (k.outer*4))]))))
              dy_dt[0] = float32((float64(vel[0])*sin(float64(thetas[(k.inner + (k.outer*4))]))))
              dtheta_dt[0] = uOpt[0]
              V_f[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] = ((((dx_dt[0]*dV_dx[0]) + (dy_dt[0]*dV_dy[0])) + (dtheta_dt[0]*dV_dT[0]))*-1.000000f)
              // attr [abs_value] storage_scope = "global"
              allocate abs_value[float32 * 1]
              produce abs_value {
                // attr [0] extern_scope = 0
                abs_value[0] = 0.000000f
              }
              if ((0.000000f < dx_dt[0])) {
                abs_value[0] = dx_dt[0]
              } else {
                abs_value[0] = (dx_dt[0]*-1.000000f)
              }
              dx_dt[0] = abs_value[0]
              // attr [abs_value] storage_scope = "global"
              allocate abs_value[float32 * 1]
              produce abs_value {
                // attr [0] extern_scope = 0
                abs_value[0] = 0.000000f
              }
              if ((0.000000f < dy_dt[0])) {
                abs_value[0] = dy_dt[0]
              } else {
                abs_value[0] = (dy_dt[0]*-1.000000f)
              }
              dy_dt[0] = abs_value[0]
              // attr [abs_value] storage_scope = "global"
              allocate abs_value[float32 * 1]
              produce abs_value {
                // attr [0] extern_scope = 0
                abs_value[0] = 0.000000f
              }
              if ((0.000000f < dtheta_dt[0])) {
                abs_value[0] = dtheta_dt[0]
              } else {
                abs_value[0] = (dtheta_dt[0]*-1.000000f)
              }
              dtheta_dt[0] = abs_value[0]
              // attr [diss] storage_scope = "global"
              allocate diss[float32 * 1]
              produce diss {
                // attr [0] extern_scope = 0
                diss[0] = 0.000000f
              }
              diss[0] = (((((dV_dx_R[0] - dV_dx_L[0])*dx_dt[0]) + ((dV_dy_R[0] - dV_dy_L[0])*dy_dt[0])) + ((dV_dT_R[0] - dV_dT_L[0])*dtheta_dt[0]))*0.500000f)
              V_f[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] = (diss[0] - V_f[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])
              if ((max_alpha1[0] < dx_dt[0])) {
                max_alpha1[0] = dx_dt[0]
              }
              if ((max_alpha2[0] < dy_dt[0])) {
                max_alpha2[0] = dy_dt[0]
              }
              if ((max_alpha3[0] < dtheta_dt[0])) {
                max_alpha3[0] = dtheta_dt[0]
              }
            }
          }
        }
      }
    }
  }
}
// attr [update0] storage_scope = "global"
allocate update0[float32 * 1]
produce update0 {
  // attr [0] extern_scope = 0
  // attr [stepBoundInv] storage_scope = "global"
  allocate stepBoundInv[float32 * 1]
  produce stepBoundInv {
    // attr [0] extern_scope = 0
    stepBoundInv[0] = 0.000000f
  }
  // attr [stepBound] storage_scope = "global"
  allocate stepBound[float32 * 1]
  produce stepBound {
    // attr [0] extern_scope = 0
    stepBound[0] = 0.000000f
  }
  stepBoundInv[0] = (((max_alpha1[0]*2.941176f) + (max_alpha2[0]*4.545455f)) + (max_alpha3[0]*4.761905f))
  stepBound[0] = (0.800000f/stepBoundInv[0])
  if ((0.050000f < stepBound[0])) {
    stepBound[0] = 0.050000f
  }
  t[0] = (t[0] + stepBound[0])
}
// attr [update1] storage_scope = "global"
allocate update1[float32 * 1]
produce update1 {
  // attr [0] extern_scope = 0
  for (i, 0, 100) {
    for (j, 0, 100) {
      for (k, 0, 100) {
        V_f[((k + (j*100)) + (i*10000))] = (V_init[((k + (j*100)) + (i*10000))] + (V_f[((k + (j*100)) + (i*10000))]*t[0]))
      }
    }
  }
}

Kernel time (s): 0.04085
Kernel time (s): 0.01052
Kernel time (s): 0.01294
Kernel time (s): 0.01305
Kernel time (s): 0.01295
Kernel time (s): 0.01195
Kernel time (s): 0.01007
Kernel time (s): 0.01017
Kernel time (s): 0.01003
Kernel time (s): 0.01093
Kernel time (s): 0.01540
Kernel time (s): 0.01312
Kernel time (s): 0.01291
Kernel time (s): 0.01303
Kernel time (s): 0.01355
Kernel time (s): 0.01318
Kernel time (s): 0.01324
Kernel time (s): 0.01335
Kernel time (s): 0.01325
Kernel time (s): 0.01319
Average kernel time (s): 0.01388
Finished solving

// attr [max_alpha1] storage_scope = "global"
allocate max_alpha1[float32 * 1]
produce max_alpha1 {
  // attr [0] extern_scope = 0
  max_alpha1[0] = -1000000000.000000f
}
// attr [max_alpha3] storage_scope = "global"
allocate max_alpha3[float32 * 1]
produce max_alpha3 {
  // attr [0] extern_scope = 0
  max_alpha3[0] = -1000000000.000000f
}
// attr [max_alpha2] storage_scope = "global"
allocate max_alpha2[float32 * 1]
produce max_alpha2 {
  // attr [0] extern_scope = 0
  max_alpha2[0] = -1000000000.000000f
}
// attr [Hamiltonian] storage_scope = "global"
allocate Hamiltonian[float32 * 1]
produce Hamiltonian {
  // attr [0] extern_scope = 0
  parallel (k.outer, 0, 25) {
    for (j.outer, 0, 25) {
      for (i.outer, 0, 25) {
        for (k.inner, 0, 4) {
          for (j.inner, 0, 4) {
            for (i.inner, 0, 4) {
              // attr [dV_dx_L] storage_scope = "global"
              allocate dV_dx_L[float32 * 1]
              produce dV_dx_L {
                // attr [0] extern_scope = 0
                dV_dx_L[0] = 0.000000f
              }
              // attr [dV_dx_R] storage_scope = "global"
              allocate dV_dx_R[float32 * 1]
              produce dV_dx_R {
                // attr [0] extern_scope = 0
                dV_dx_R[0] = 0.000000f
              }
              // attr [dV_dx] storage_scope = "global"
              allocate dV_dx[float32 * 1]
              produce dV_dx {
                // attr [0] extern_scope = 0
                dV_dx[0] = 0.000000f
              }
              // attr [dV_dy_L] storage_scope = "global"
              allocate dV_dy_L[float32 * 1]
              produce dV_dy_L {
                // attr [0] extern_scope = 0
                dV_dy_L[0] = 0.000000f
              }
              // attr [dV_dy_R] storage_scope = "global"
              allocate dV_dy_R[float32 * 1]
              produce dV_dy_R {
                // attr [0] extern_scope = 0
                dV_dy_R[0] = 0.000000f
              }
              // attr [dV_dy] storage_scope = "global"
              allocate dV_dy[float32 * 1]
              produce dV_dy {
                // attr [0] extern_scope = 0
                dV_dy[0] = 0.000000f
              }
              // attr [dV_dT_L] storage_scope = "global"
              allocate dV_dT_L[float32 * 1]
              produce dV_dT_L {
                // attr [0] extern_scope = 0
                dV_dT_L[0] = 0.000000f
              }
              // attr [dV_dT_R] storage_scope = "global"
              allocate dV_dT_R[float32 * 1]
              produce dV_dT_R {
                // attr [0] extern_scope = 0
                dV_dT_R[0] = 0.000000f
              }
              // attr [dV_dT] storage_scope = "global"
              allocate dV_dT[float32 * 1]
              produce dV_dT {
                // attr [0] extern_scope = 0
                dV_dT[0] = 0.000000f
              }
              // attr [dx_dt] storage_scope = "global"
              allocate dx_dt[float32 * 1]
              produce dx_dt {
                // attr [0] extern_scope = 0
                dx_dt[0] = 0.000000f
              }
              // attr [dy_dt] storage_scope = "global"
              allocate dy_dt[float32 * 1]
              produce dy_dt {
                // attr [0] extern_scope = 0
                dy_dt[0] = 0.000000f
              }
              // attr [dtheta_dt] storage_scope = "global"
              allocate dtheta_dt[float32 * 1]
              produce dtheta_dt {
                // attr [0] extern_scope = 0
                dtheta_dt[0] = 0.000000f
              }
              // attr [left_deriv] storage_scope = "global"
              allocate left_deriv[float32 * 1]
              produce left_deriv {
                // attr [0] extern_scope = 0
                left_deriv[0] = 0.000000f
              }
              // attr [right_deriv] storage_scope = "global"
              allocate right_deriv[float32 * 1]
              produce right_deriv {
                // attr [0] extern_scope = 0
                right_deriv[0] = 0.000000f
              }
              if (((i.inner + (i.outer*4)) == 0)) {
                // attr [left_boundary] storage_scope = "global"
                allocate left_boundary[float32 * 1]
                produce left_boundary {
                  // attr [0] extern_scope = 0
                  left_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)] - V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)] - V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))])
                } else {
                  abs_value[0] = (V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                left_boundary[0] = (V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))] - left_boundary[0])*2.941176f)
                right_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 10000)] - V_init[((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100))])*2.941176f)
              } else if (((i.inner + (i.outer*4)) == 99)) {
                // attr [right_boundary] storage_scope = "global"
                allocate right_boundary[float32 * 1]
                produce right_boundary {
                  // attr [0] extern_scope = 0
                  right_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)])
                } else {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                right_boundary[0] = (V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 980000)])*2.941176f)
                right_deriv[0] = ((right_boundary[0] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + 990000)])*2.941176f)
              } else if (((i.inner + (i.outer*4)) != 99)) {
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] - V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + -10000)])*2.941176f)
                right_deriv[0] = ((V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + 10000)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])*2.941176f)
              }
              dV_dx_L[0] = left_deriv[0]
              dV_dx_R[0] = right_deriv[0]
              // attr [left_deriv] storage_scope = "global"
              allocate left_deriv[float32 * 1]
              produce left_deriv {
                // attr [0] extern_scope = 0
                left_deriv[0] = 0.000000f
              }
              // attr [right_deriv] storage_scope = "global"
              allocate right_deriv[float32 * 1]
              produce right_deriv {
                // attr [0] extern_scope = 0
                right_deriv[0] = 0.000000f
              }
              if (((j.inner + (j.outer*4)) == 0)) {
                // attr [left_boundary] storage_scope = "global"
                allocate left_boundary[float32 * 1]
                produce left_boundary {
                  // attr [0] extern_scope = 0
                  left_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))])
                } else {
                  abs_value[0] = (V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                left_boundary[0] = (V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))] - left_boundary[0])*4.545455f)
                right_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000))])*4.545455f)
              } else if (((j.inner + (j.outer*4)) == 99)) {
                // attr [right_boundary] storage_scope = "global"
                allocate right_boundary[float32 * 1]
                produce right_boundary {
                  // attr [0] extern_scope = 0
                  right_boundary[0] = 0.000000f
                }
                // attr [abs_value] storage_scope = "global"
                allocate abs_value[float32 * 1]
                produce abs_value {
                  // attr [0] extern_scope = 0
                  abs_value[0] = 0.000000f
                }
                if ((0.000000f < (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)]))) {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)])
                } else {
                  abs_value[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)])
                }
                // attr [sign] storage_scope = "global"
                allocate sign[float32 * 1]
                produce sign {
                  // attr [0] extern_scope = 0
                  sign[0] = 0.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] == 0.000000f)) {
                  sign[0] = 0.000000f
                }
                if ((0.000000f < V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)])) {
                  sign[0] = 1.000000f
                }
                if ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] < 0.000000f)) {
                  sign[0] = -1.000000f
                }
                right_boundary[0] = (V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] + (abs_value[0]*sign[0]))
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9800)])*4.545455f)
                right_deriv[0] = ((right_boundary[0] - V_init[(((k.inner + (k.outer*4)) + ((i.inner + (i.outer*4))*10000)) + 9900)])*4.545455f)
              } else if (((j.inner + (j.outer*4)) != 99)) {
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] - V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + -100)])*4.545455f)
                right_deriv[0] = ((V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + 100)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])*4.545455f)
              }
              dV_dy_L[0] = left_deriv[0]
              dV_dy_R[0] = right_deriv[0]
              // attr [left_deriv] storage_scope = "global"
              allocate left_deriv[float32 * 1]
              produce left_deriv {
                // attr [0] extern_scope = 0
                left_deriv[0] = 0.000000f
              }
              // attr [right_deriv] storage_scope = "global"
              allocate right_deriv[float32 * 1]
              produce right_deriv {
                // attr [0] extern_scope = 0
                right_deriv[0] = 0.000000f
              }
              if (((k.inner + (k.outer*4)) == 0)) {
                // attr [left_boundary] storage_scope = "global"
                allocate left_boundary[float32 * 1]
                produce left_boundary {
                  // attr [0] extern_scope = 0
                  left_boundary[0] = 0.000000f
                }
                left_boundary[0] = V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 50)]
                left_deriv[0] = ((V_init[(((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100)] - left_boundary[0])*4.761905f)
                right_deriv[0] = ((V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 1)] - V_init[(((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100)])*4.761905f)
              } else if (((k.inner + (k.outer*4)) == 99)) {
                // attr [right_boundary] storage_scope = "global"
                allocate right_boundary[float32 * 1]
                produce right_boundary {
                  // attr [0] extern_scope = 0
                  right_boundary[0] = 0.000000f
                }
                right_boundary[0] = V_init[(((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100)]
                left_deriv[0] = ((V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 99)] - V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 98)])*4.761905f)
                right_deriv[0] = ((right_boundary[0] - V_init[((((j.inner + (j.outer*4)) + ((i.inner + (i.outer*4))*100))*100) + 99)])*4.761905f)
              } else if (((k.inner + (k.outer*4)) != 99)) {
                left_deriv[0] = ((V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] - V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + -1)])*4.761905f)
                right_deriv[0] = ((V_init[((((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000)) + 1)] - V_init[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])*4.761905f)
              }
              dV_dT_L[0] = left_deriv[0]
              dV_dT_R[0] = right_deriv[0]
              dV_dx[0] = ((dV_dx_L[0] + dV_dx_R[0])*0.500000f)
              dV_dy[0] = ((dV_dy_L[0] + dV_dy_R[0])*0.500000f)
              dV_dT[0] = ((dV_dT_L[0] + dV_dT_R[0])*0.500000f)
              // attr [uOpt] storage_scope = "global"
              allocate uOpt[float32 * 1]
              produce uOpt {
                // attr [0] extern_scope = 0
                uOpt[0] = 0.000000f
              }
              // attr [vel] storage_scope = "global"
              allocate vel[float32 * 1]
              produce vel {
                // attr [0] extern_scope = 0
                vel[0] = 1.000000f
              }
              if ((0.000000f < dV_dT[0])) {
                uOpt[0] = (uOpt[0]*-1.000000f)
              }
              dx_dt[0] = float32((float64(vel[0])*cos(float64(thetas[(k.inner + (k.outer*4))]))))
              dy_dt[0] = float32((float64(vel[0])*sin(float64(thetas[(k.inner + (k.outer*4))]))))
              dtheta_dt[0] = uOpt[0]
              V_f[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] = ((((dx_dt[0]*dV_dx[0]) + (dy_dt[0]*dV_dy[0])) + (dtheta_dt[0]*dV_dT[0]))*-1.000000f)
              // attr [abs_value] storage_scope = "global"
              allocate abs_value[float32 * 1]
              produce abs_value {
                // attr [0] extern_scope = 0
                abs_value[0] = 0.000000f
              }
              if ((0.000000f < dx_dt[0])) {
                abs_value[0] = dx_dt[0]
              } else {
                abs_value[0] = (dx_dt[0]*-1.000000f)
              }
              dx_dt[0] = abs_value[0]
              // attr [abs_value] storage_scope = "global"
              allocate abs_value[float32 * 1]
              produce abs_value {
                // attr [0] extern_scope = 0
                abs_value[0] = 0.000000f
              }
              if ((0.000000f < dy_dt[0])) {
                abs_value[0] = dy_dt[0]
              } else {
                abs_value[0] = (dy_dt[0]*-1.000000f)
              }
              dy_dt[0] = abs_value[0]
              // attr [abs_value] storage_scope = "global"
              allocate abs_value[float32 * 1]
              produce abs_value {
                // attr [0] extern_scope = 0
                abs_value[0] = 0.000000f
              }
              if ((0.000000f < dtheta_dt[0])) {
                abs_value[0] = dtheta_dt[0]
              } else {
                abs_value[0] = (dtheta_dt[0]*-1.000000f)
              }
              dtheta_dt[0] = abs_value[0]
              // attr [diss] storage_scope = "global"
              allocate diss[float32 * 1]
              produce diss {
                // attr [0] extern_scope = 0
                diss[0] = 0.000000f
              }
              diss[0] = (((((dV_dx_R[0] - dV_dx_L[0])*dx_dt[0]) + ((dV_dy_R[0] - dV_dy_L[0])*dy_dt[0])) + ((dV_dT_R[0] - dV_dT_L[0])*dtheta_dt[0]))*0.500000f)
              V_f[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))] = (diss[0] - V_f[(((k.inner + (k.outer*4)) + ((j.inner + (j.outer*4))*100)) + ((i.inner + (i.outer*4))*10000))])
              if ((max_alpha1[0] < dx_dt[0])) {
                max_alpha1[0] = dx_dt[0]
              }
              if ((max_alpha2[0] < dy_dt[0])) {
                max_alpha2[0] = dy_dt[0]
              }
              if ((max_alpha3[0] < dtheta_dt[0])) {
                max_alpha3[0] = dtheta_dt[0]
              }
            }
          }
        }
      }
    }
  }
}
// attr [update0] storage_scope = "global"
allocate update0[float32 * 1]
produce update0 {
  // attr [0] extern_scope = 0
  // attr [stepBoundInv] storage_scope = "global"
  allocate stepBoundInv[float32 * 1]
  produce stepBoundInv {
    // attr [0] extern_scope = 0
    stepBoundInv[0] = 0.000000f
  }
  // attr [stepBound] storage_scope = "global"
  allocate stepBound[float32 * 1]
  produce stepBound {
    // attr [0] extern_scope = 0
    stepBound[0] = 0.000000f
  }
  stepBoundInv[0] = (((max_alpha1[0]*2.941176f) + (max_alpha2[0]*4.545455f)) + (max_alpha3[0]*4.761905f))
  stepBound[0] = (0.800000f/stepBoundInv[0])
  if ((0.050000f < stepBound[0])) {
    stepBound[0] = 0.050000f
  }
  t[0] = (t[0] + stepBound[0])
}
// attr [update1] storage_scope = "global"
allocate update1[float32 * 1]
produce update1 {
  // attr [0] extern_scope = 0
  for (i, 0, 100) {
    for (j, 0, 100) {
      for (k, 0, 100) {
        V_f[((k + (j*100)) + (i*10000))] = (V_init[((k + (j*100)) + (i*10000))] + (V_f[((k + (j*100)) + (i*10000))]*t[0]))
      }
    }
  }
}

Kernel time (s): 0.02160
Kernel time (s): 0.00325
Kernel time (s): 0.00333
Kernel time (s): 0.00427
Kernel time (s): 0.00402
Kernel time (s): 0.00434
Kernel time (s): 0.00438
Kernel time (s): 0.00442
Kernel time (s): 0.00439
Kernel time (s): 0.00332
Kernel time (s): 0.00334
Kernel time (s): 0.00332
Kernel time (s): 0.00338
Kernel time (s): 0.00339
Kernel time (s): 0.00337
Kernel time (s): 0.00333
Kernel time (s): 0.00341
Kernel time (s): 0.00339
Kernel time (s): 0.00338
Kernel time (s): 0.00324
Average kernel time (s): 0.00454
Finished solving

